}
vol = dd*(nrow(points)*raster::ncell(grid))/1024/1024/1024;
targ.n = as.integer(5/vol);
if(targ.n > raster::ncell(grid)) {
splits = seq(1:raster::ncell(grid))
} else {
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
}
.gkde.core.p <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
if(parallel == FALSE){
di = unlist(lapply(splits, .gkde.core.p));
} else {
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
}
} else {
cat("ERR1: Bad Distance method declaration\n");
return(NULL);
}
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
return(r);
}
di = gkde(grid, points, parallel=FALSE, dist.method='Pythagorean');
dd = 16; #16 bytes per cell.
vol = dd*(nrow(points)^2)/1024/1024/1024;
if (vol > 2){#if distance matrix will be > than
##Bootstrap bandwidth selection
n= 10000;
bw = vector();
for(i in 1:n){
sam = sample(c(1:nrow(points)), 100, replace =TRUE)
p = points[sam,];
ps = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw[i] = stats::bw.nrd(as.vector(ps));
}
bw.gen = median(bw);
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw.gen = stats::bw.nrd(as.vector(pbp));
}
bw.gen
vol = dd*(nrow(points)*raster::ncell(grid))/1024/1024/1024;
targ.n = as.integer(5/vol);
if(targ.n > raster::ncell(grid)) {
splits = seq(1:raster::ncell(grid))
} else {
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
}
splits
.gkde.core.p <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
if(parallel == FALSE){
di = unlist(lapply(splits, .gkde.core.p));
} else {
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
}
parallel=FALSE
if(parallel == FALSE){
di = unlist(lapply(splits, .gkde.core.p));
} else {
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
}
di
di = gkde(grid, points, parallel=FALSE, dist.method='Pythagorean');
plot(di)
require(raster)
grid = raster::raster(nrows=18, ncols=36, xmn=-180, xmx=180, ymn=-90, ymx=90, vals=NULL)
grid = raster::setValues(grid,values=(as.vector(seq(1:raster::ncell(grid)))))
points = cbind(seq(xmin(grid), xmax(grid), length.out=100),
seq(ymin(grid), ymax(grid), length.out=100))
plot(grid); points(points);
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
plot(di)
devtools::check()
devtools::check()
gkde <- function(grid, points, parallel=TRUE, nclus = 4, dist.method = 'Haversine'){
zz = seq(1:raster::ncell(grid)); ##Pass to gkde
if(dist.method == "Haversine"){
pbp = as.vector(distance(as.matrix(points), as.matrix(points)));
np = length(pbp);
if(np > 1000000000){
pbp = pbp[1:50000000];
cat("NOTE: Subsetting points for bandwidth selection");
}
bw.gen = stats::bw.nrd(as.vector(pbp));
xx = seq(1:raster::ncell(grid));
std = 0.00000001136095; ##approximate GB/cell in an R matrix.
nm = 1/(1.34*std*raster::ncell(grid)); ##Number of rows to hit 1GB
n=10*nm;
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
splits = split(xx, f);
.gkde.core.h <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = distance(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
if(parallel == FALSE){
di = unlist(lapply(splits, .gkde.core.p));
} else {
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.h));
parallel::stopCluster(cl);
}
} else if(dist.method == "Pythagorean"){
#one cell of a matrix should contain a double, so:
dd = 16; #16 bytes per cell.
vol = dd*(nrow(points)^2)/1024/1024/1024;
if (vol > 2){#if distance matrix will be > than
##Bootstrap bandwidth selection
n= 10000;
bw = vector();
for(i in 1:n){
sam = sample(c(1:nrow(points)), 100, replace =TRUE)
p = points[sam,];
ps = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw[i] = stats::bw.nrd(as.vector(ps));
}
bw.gen = stats::median(bw);
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw.gen = stats::bw.nrd(as.vector(pbp));
}
vol = dd*(nrow(points)*raster::ncell(grid))/1024/1024/1024;
targ.n = as.integer(5/vol);
if(targ.n > raster::ncell(grid)) {
splits = seq(1:raster::ncell(grid))
} else {
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
}
.gkde.core.p <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
if(parallel == FALSE){
di = unlist(lapply(splits, .gkde.core.p));
} else {
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
}
} else {
cat("ERR1: Bad Distance method declaration\n");
return(NULL);
}
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
return(r);
}
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
dd = 16; #16 bytes per cell.
vol = dd*(nrow(points)^2)/1024/1024/1024;
if (vol > 2){#if distance matrix will be > than
##Bootstrap bandwidth selection
n= 10000;
bw = vector();
for(i in 1:n){
sam = sample(c(1:nrow(points)), 100, replace =TRUE)
p = points[sam,];
ps = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw[i] = stats::bw.nrd(as.vector(ps));
}
bw.gen = stats::median(bw);
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)));
bw.gen = stats::bw.nrd(as.vector(pbp));
}
bw.gen
vol = dd*(nrow(points)*raster::ncell(grid))/1024/1024/1024;
targ.n = as.integer(5/vol);
if(targ.n > raster::ncell(grid)) {
splits = seq(1:raster::ncell(grid))
} else {
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
}
splits
list(splits)
vol = dd*(nrow(points)*raster::ncell(grid))/1024/1024/1024;
targ.n = as.integer(5/vol);
if(targ.n > raster::ncell(grid)) {
splits = list(seq(1:raster::ncell(grid)));
} else {
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
}
splits
.gkde.core.p <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
di = unlist(lapply(splits, .gkde.core.p));
di
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
plot(r)
cl = parallel::makeCluster(nclus, type ='SOCK');
nclus =2
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
?clusterExport
parallel::stopCluster(cl);
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=.GlobalEnv);
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
.gkde.core.p <- function(x){
require(rasterExtras)
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
parallel::stopCluster(cl);
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=.GlobalEnv);
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
.gkde.core.p <- function(x){
require(rasterExtras)
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=.GlobalEnv);
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
.gkde.core.p <- function(x){
require(rasterExtras)
coords = rasterExtras::latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=.GlobalEnv);
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
.gkde.core.p <- function(x){
coords = latlonfromcell(as.vector(x),
as.vector(c(raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid));
d = pythagorean(as.matrix(coords[,2:1]),as.matrix(points));
di=vector();
for(c in 1:raster::nrow(coords)){
di[c] = stats::density(d[c,], n = 1, kernel = 'gaussian', from = 0,  to = 0,  bw = bw.gen, na.rm = TRUE)$y;
}
return(di);
}
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
di = unlist(lapply(splits, .gkde.core.p));
zz = as.integer(raster::ncell(grid)/targ.n);
zz
splits = split(xx, zz);
splits
splits = split(xx, 1);
splits
di = unlist(lapply(splits, .gkde.core.p));
di
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
plot(r)
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
splits
if(nclus > length(splits)){
nclus = length(splits)
}
nclus
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "splits"),envir=.GlobalEnv);
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p));
parallel::stopCluster(cl);
devtools::check()
devtools::check()
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
library(rasterExtras)
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
devtools::install_git('https://github.com/rsh249/rasterExtras')
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
di = gkde(grid, points, parallel=FALSE, dist.method='Pythagorean');
devtools::check()
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
splits
class(splits)
splits = list(seq(1:raster::ncell(grid)));
class(splits)
splitList(seq(1:ncell(grid)), 4)
splitLists(seq(1:ncell(grid)), 4)
?unlist
splits
unlist(splits)
splits = split(unlist(splits), nclus)
splits
splits = split(unlist(splits), nclus)
splits
summary(splits)
length(splits)
?split
if(nclus > length(splits)){
splits = cut(xx, nclus)
}
nclus
length(splits)
splits
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "latlonfromcell", "pythagorean"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p)); ##Error in compatible types here;;;
parallel::stopCluster(cl);
nclus = 4
length(splits)
splits = cut(xx, nclus)
splits
head(splits)
?cut
xx
split(xx, c(1:3, 4))
splits = cut(xx, 1:nclus)
splits
splits = split(xx, 1:nclus)
splits
parallel::clusterSplit(cl, xx)
cl
nclus
cl = parallel::makeCluster(nclus, type ='SOCK');
if(nclus > length(splits)){
splits = parallel::clusterSplit(cl, xx);
}
splits
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "latlonfromcell", "pythagorean"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p)); ##Error in compatible types here;;;
parallel::stopCluster(cl);
di
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
plot(r)
splits
?clusterSplit
xx
splits = split(xx, 1:nclus)
splits
if(nclus > length(splits)){
splits = split(xx, 1:nclus)
}
?split
splits = split(xx, 1:nclus,1)
splits
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
xx = seq(1:raster::ncell(grid));
std = 0.00000001136095; ##approximate GB/cell in an R matrix.
nm = 1/(1.34*std*raster::ncell(grid)); ##Number of rows to hit 1GB
n=10*nm;
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
f
n=nclus;
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
splits = split(xx, 1:nclus,1)
splits
splits = split(xx,f)
splits
f
n=length(xx)/nclus;
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
splits = split(xx,f)
splits
if(nclus > length(splits)){
n=length(xx)/nclus;
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
splits = split(xx,f)
}
cl = parallel::makeCluster(nclus, type ='SOCK');
parallel::clusterExport(cl, c("grid", "points", "bw.gen", "latlonfromcell", "pythagorean"),envir=environment());
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p)); ##Error in compatible types here;;;
parallel::stopCluster(cl);
r=raster::raster(nrows=nrow(grid),ncol=ncol(grid), crs="+proj=longlat +datum=WGS84",ext=raster::extent(grid))
r=raster::setValues(r,values=di);
r = raster::mask(r, grid);
plot(r)
zz = as.integer(raster::ncell(grid)/targ.n);
splits = split(xx, zz);
splits
targ.n
n = targ.n
f <- sort(rep(1:(trunc(length(xx)/n)+1),n))[1:length(xx)]
splits = split(xx,f)
splits
