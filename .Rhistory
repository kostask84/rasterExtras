.gkde.core.p <- function(x) {
coords = latlonfromcell(as.vector(x),
as.vector(
c(
raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid))
d = pythagorean(as.matrix(coords[, 2:1]), as.matrix(points))
di = vector()
for (c in 1:raster::nrow(coords)) {
di[c] = stats::density(
d[c, ],
n = 1,
kernel = 'gaussian',
from = 0,
to = 0,
bw = bw.gen,
na.rm = TRUE
)$y
}
return(di)
}
xx = seq(1:raster::ncell(grid))
#one cell of a matrix should contain a double, so:
dd = 32
#16 bytes per cell. Estimates seem off using this value for memory of doubles in matrices
vol = dd * (nrow(points) ^ 2) / 1024 / 1024 / 1024
if (vol > 2) {
#if distance matrix will be > than ???
##Bootstrap bandwidth selection
n = 10000
bw = vector()
for (i in 1:n) {
sam = sample(c(1:nrow(points)), 100, replace = TRUE)
p = points[sam, ]
if (dist.method == "Pythagorean") {
ps = as.vector(pythagorean(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
} else if (dist.method == "Haversine") {
ps = as.vector(distance(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
}
bw[i] = stats::bw.nrd(as.vector(ps))
}
bw.gen = stats::median(bw)
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
if (dist.method == "Pythagorean") {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
} else if (dist.method == "Haversine") {
pbp = as.vector(distance(as.matrix(points), as.matrix(points)))
}
bw.gen = stats::bw.nrd(as.vector(pbp))
}
##Check grid x points matrix size.
vol = (dd * (nrow(points) * raster::ncell(grid))) / 1024 / 1024 / 1024
ramtarg= 5;
targ.n = ceiling((ramtarg / vol) * raster::ncell(grid))
if (targ.n > raster::ncell(grid)) {
splits = list(seq(1:raster::ncell(grid)))
} else {
n = targ.n
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
if (parallel == FALSE) {
if (dist.method == "Pythagorean") {
di = unlist(lapply(splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(lapply(splits, .gkde.core.h))
}
} else {
if (nclus > length(splits)) {
n = length(xx) / nclus
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
##Reporting bloc
cat("BEGIN PARALLEL COMPUTATION\n");
cat("Threadcount: ", nclus, "\n");
cat("Cells/iteration: ", length(splits[[1]]), "of", ncell(grid), "\n")
cat("Points: ", nrow(points), "\n");
cat("Target RAM per thread", ramtarg/nclus, "\n");
cat("Distance Method: ", dist.method, "\n");
###
cl = parallel::makeCluster(nclus, type = 'SOCK')
parallel::clusterExport(cl,
c(
"grid",
"points",
"bw.gen",
"latlonfromcell",
"pythagorean"
),
envir = environment())
if (dist.method == "Pythagorean") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.h))
}
parallel::stopCluster(cl)
}
r = raster::raster(
nrows = nrow(grid),
ncol = ncol(grid),
crs = "+proj=longlat +datum=WGS84",
ext = raster::extent(grid)
)
r = raster::setValues(r, values = di)
r = raster::mask(r, grid)
return(r)
}
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
gkde <-
function(grid,
points,
parallel = TRUE,
nclus = 4,
dist.method = 'Haversine') {
.gkde.core.h <- function(x) {
require(rasterExtras)
coords = latlonfromcell(as.vector(x),
as.vector(
c(
raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid))
d = distance(as.matrix(coords[, 2:1]), as.matrix(points))
di = vector()
for (c in 1:raster::nrow(coords)) {
di[c] = stats::density(
d[c, ],
n = 1,
kernel = 'gaussian',
from = 0,
to = 0,
bw = bw.gen,
na.rm = TRUE
)$y
}
return(di)
}
.gkde.core.p <- function(x) {
coords = latlonfromcell(as.vector(x),
as.vector(
c(
raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid))
d = pythagorean(as.matrix(coords[, 2:1]), as.matrix(points))
di = vector()
for (c in 1:raster::nrow(coords)) {
di[c] = stats::density(
d[c, ],
n = 1,
kernel = 'gaussian',
from = 0,
to = 0,
bw = bw.gen,
na.rm = TRUE
)$y
}
return(di)
}
xx = seq(1:raster::ncell(grid))
#one cell of a matrix should contain a double, so:
dd = 32
#16 bytes per cell. Estimates seem off using this value for memory of doubles in matrices
vol = dd * (nrow(points) ^ 2) / 1024 / 1024 / 1024
if (vol > 2) {
#if distance matrix will be > than ???
##Bootstrap bandwidth selection
n = 10000
bw = vector()
for (i in 1:n) {
sam = sample(c(1:nrow(points)), 100, replace = TRUE)
p = points[sam, ]
if (dist.method == "Pythagorean") {
ps = as.vector(pythagorean(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
} else if (dist.method == "Haversine") {
ps = as.vector(distance(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
}
bw[i] = stats::bw.nrd(as.vector(ps))
}
bw.gen = stats::median(bw)
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
if (dist.method == "Pythagorean") {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
} else if (dist.method == "Haversine") {
pbp = as.vector(distance(as.matrix(points), as.matrix(points)))
}
bw.gen = stats::bw.nrd(as.vector(pbp))
}
##Check grid x points matrix size.
vol = (dd * (nrow(points) * raster::ncell(grid))) / 1024 / 1024 / 1024
ramtarg= 5;
targ.n = ceiling((ramtarg / vol) * raster::ncell(grid))
if (targ.n > raster::ncell(grid)) {
splits = list(seq(1:raster::ncell(grid)))
} else {
n = targ.n
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
if (parallel == FALSE) {
if (dist.method == "Pythagorean") {
di = unlist(lapply(splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(lapply(splits, .gkde.core.h))
}
} else {
if (nclus > length(splits)) {
n = length(xx) / nclus
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
##Reporting bloc
cat("BEGIN PARALLEL COMPUTATION\n");
cat("Core count: ", nclus, "\n");
cat("Cells/iteration: ", length(splits[[1]]), "of", ncell(grid), "\n")
cat("Points: ", nrow(points), "\n");
cat("Target RAM per proc.: ", ramtarg/nclus, "\n");
cat("Distance Method: ", dist.method, "\n");
###
cl = parallel::makeCluster(nclus, type = 'SOCK')
parallel::clusterExport(cl,
c(
"grid",
"points",
"bw.gen",
"latlonfromcell",
"pythagorean"
),
envir = environment())
if (dist.method == "Pythagorean") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.h))
}
parallel::stopCluster(cl)
}
r = raster::raster(
nrows = nrow(grid),
ncol = ncol(grid),
crs = "+proj=longlat +datum=WGS84",
ext = raster::extent(grid)
)
r = raster::setValues(r, values = di)
r = raster::mask(r, grid)
return(r)
}
gkde <-
function(grid,
points,
parallel = TRUE,
nclus = 4,
dist.method = 'Haversine') {
.gkde.core.h <- function(x) {
require(rasterExtras)
coords = latlonfromcell(as.vector(x),
as.vector(
c(
raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid))
d = distance(as.matrix(coords[, 2:1]), as.matrix(points))
di = vector()
for (c in 1:raster::nrow(coords)) {
di[c] = stats::density(
d[c, ],
n = 1,
kernel = 'gaussian',
from = 0,
to = 0,
bw = bw.gen,
na.rm = TRUE
)$y
}
return(di)
}
.gkde.core.p <- function(x) {
coords = latlonfromcell(as.vector(x),
as.vector(
c(
raster::xmin(grid),
raster::xmax(grid),
raster::ymin(grid),
raster::ymax(grid)
)
),
nrow(grid),
ncol(grid))
d = pythagorean(as.matrix(coords[, 2:1]), as.matrix(points))
di = vector()
for (c in 1:raster::nrow(coords)) {
di[c] = stats::density(
d[c, ],
n = 1,
kernel = 'gaussian',
from = 0,
to = 0,
bw = bw.gen,
na.rm = TRUE
)$y
}
return(di)
}
xx = seq(1:raster::ncell(grid))
#one cell of a matrix should contain a double, so:
dd = 32
#16 bytes per cell. Estimates seem off using this value for memory of doubles in matrices
vol = dd * (nrow(points) ^ 2) / 1024 / 1024 / 1024
if (vol > 2) {
#if distance matrix will be > than ???
##Bootstrap bandwidth selection
n = 10000
bw = vector()
for (i in 1:n) {
sam = sample(c(1:nrow(points)), 100, replace = TRUE)
p = points[sam, ]
if (dist.method == "Pythagorean") {
ps = as.vector(pythagorean(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
} else if (dist.method == "Haversine") {
ps = as.vector(distance(as.matrix(points[sam, ]), as.matrix(points[sam, ])))
}
bw[i] = stats::bw.nrd(as.vector(ps))
}
bw.gen = stats::median(bw)
} else {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
if (dist.method == "Pythagorean") {
pbp = as.vector(pythagorean(as.matrix(points), as.matrix(points)))
} else if (dist.method == "Haversine") {
pbp = as.vector(distance(as.matrix(points), as.matrix(points)))
}
bw.gen = stats::bw.nrd(as.vector(pbp))
}
##Check grid x points matrix size.
vol = (dd * (nrow(points) * raster::ncell(grid))) / 1024 / 1024 / 1024
ramtarg= 5;
targ.n = ceiling((ramtarg / vol) * raster::ncell(grid))
if (targ.n > raster::ncell(grid)) {
splits = list(seq(1:raster::ncell(grid)))
} else {
n = targ.n
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
if (parallel == FALSE) {
if (dist.method == "Pythagorean") {
di = unlist(lapply(splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(lapply(splits, .gkde.core.h))
}
} else {
if (nclus > length(splits)) {
n = length(xx) / nclus
f <- sort(rep(1:(trunc(length(
xx
) / n) + 1), n))[1:length(xx)]
splits = split(xx, f)
}
##Reporting bloc
cat("BEGIN PARALLEL COMPUTATION\n");
cat("Core count: ", nclus, "\n");
cat("Cells/iteration: ", length(splits[[1]]), "of", ncell(grid), "\n")
cat("Points: ", nrow(points), "\n");
cat("Target RAM per proc.: ", ramtarg/nclus, "\n");
cat("Distance Method: ", dist.method, "\n");
###
cl = parallel::makeCluster(nclus, type = 'SOCK')
parallel::clusterExport(cl,
c(
"grid",
"points",
"bw.gen",
"latlonfromcell",
"pythagorean"
),
envir = environment())
if (dist.method == "Pythagorean") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.p))
} else if (dist.method == "Haversine") {
di = unlist(parallel::parLapply(cl, splits, .gkde.core.h))
}
parallel::stopCluster(cl)
}
r = raster::raster(
nrows = nrow(grid),
ncol = ncol(grid),
crs = "+proj=longlat +datum=WGS84",
ext = raster::extent(grid)
)
r = raster::setValues(r, values = di)
r = raster::mask(r, grid)
return(r)
}
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
162*4
grid = raster::raster(nrows=800, ncols=360, xmn=-180, xmx=180, ymn=-90, ymx=90, vals=NULL)
grid = raster::setValues(grid,values=(as.vector(seq(1:raster::ncell(grid)))))
points = cbind(seq(xmin(grid), xmax(grid), length.out=1000),
seq(ymin(grid), ymax(grid), length.out=100))
plot(grid); points(points);
di = gkde(grid, points, parallel=TRUE, dist.method='Pythagorean');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
plot(di)
grid = raster::raster(nrows=360, ncols=360, xmn=-180, xmx=180, ymn=-90, ymx=90, vals=NULL)
grid = raster::setValues(grid,values=(as.vector(seq(1:raster::ncell(grid)))))
points = cbind(seq(xmin(grid), xmax(grid), length.out=1000),
seq(ymin(grid), ymax(grid), length.out=100))
plot(grid); points(points);
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Pythagorean');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
ep
p=proc.time();
ep = proc.time() - p;
ep
cat(ep)
ep[[3]]
source('~/GitHub/rasterExtras/R/gkde_fun.R')
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Pythagorean');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
getwd()
setwd('~/GitHub/rasterExtras/')
devtools::check()
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Haversine');
points
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Haversine');
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Pythagorean');
plot(di)
di = gkde(grid, points, parallel=TRUE, nclus = 2, dist.method='Haversine');
di = gkde(grid, points, parallel=FALSE, nclus = 2, dist.method='Haversine');
pbp = as.vector(distance(as.matrix(points), as.matrix(points)))
pbp
summary(pbp)
source('~/GitHub/rasterExtras/R/gkde_fun.R')
di = gkde(grid, points, parallel=FALSE, nclus = 2, dist.method='Haversine');
plot(di)
di = gkde(grid, points, parallel=T, nclus = 2, dist.method='Haversine');
plot(di)
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
di = gkde(grid, points, parallel=T, nclus = 2, dist.method='Haversine');
source('~/GitHub/rasterExtras/R/gkde_fun.R')
plot(di)
getwd()
devtools::check(cran=TRUE)
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
devtools::check(cran=TRUE)
source('~/GitHub/rasterExtras/R/gkde_fun.R')
devtools::check(cran=TRUE)
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
source('~/GitHub/rasterExtras/R/gkde_fun.R')
500*1200
600000
